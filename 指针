一、指针概念
    计算机内存（memory）中，整型占据4字节（byte）内存，浮点型占据4字节，字符型占据1字节。每个字节占据一个地址（address），例如声明一个整型变量a，a的地址为205，a的值（value)为5，那么a占据205-208。
    当我们用p来表示一个指针（pointer），p指向a的地址，计算机先到这个地址，再去对a进行操作。Pointers are variables that store address of variables.
示例
#include<stdio.h>
int main() {
	int a = 5;
	int* p;//int *p等价
	p = &a;
	printf("%d\n", a);//打印结果为5，a的值
	printf("%p\n", p);//打印结果为000000B1083FF9B4，十六进制，即p的值，a的地址
	printf("%d\n", *p);//打印结果为5，*p表示对p进行解引用，即去p表示的地址，获得这个地址所储存的值
	*p=9;//对p这个地址所储存的变量的值重新赋值为9
	printf("%d\n", a);//打印结果为9
}

二、指针声明（declare）
   1.int a;                   
     int *p1 = &a;
     char b;  
     char *p2=&b;
     double c;     
     double *c=&c;
   2.&p     // 获取指针变量p本身的地址
     *(&p)  // 解引用p的地址，得到p本身

     &x//获得x的地址
     *（&x）//解引用x的地址，获得x的值本身

     *p//解引用指针变量p，得到p指向的值
     &（*p）//获得这个变量的地址
   3.int *p1,*p2;//p1是指针，p2是指针
     int *p1，p2；//p1是指针，p2是整型



三、指针运算
p++增加sizeof（int)或者char（1bytes）或者double（8bytes）

示例
#include<stdio.h>
int main() {
	int a = 5;
	int* p;
	p = &a;
	
	printf("Address p is %p\n", p);//Address p is 0000003C23CFF864
	printf("size of the integer is %d bytes.\n", (unsigned)sizeof(int));//size of the integer is 4 bytes.
	printf("Address p+2 is %p.\n", p + 2);//Address p+2 is 0000003C23CFF86C.加了两个整数型所需位置，
    printf("Value at address p+1 is %d", *(p + 1));//Value at address p+1 is -858993460,这是随机的垃圾值
}

四、指针是强类型的
    1.因为指针不仅是保存地址，也起解引用的作用来访问地址并修改里面的值。
#include<stdio.h>
int main() {
	int a = 1025;
	int* p;
	p = &a;
	
	char* p0;
	p0 = (char*)p;//类型转换
	printf("Size of char is %d bytes.\n",(unsigned)sizeof(char));
	printf("Address = %p,value = %d \n", p0, *p0);//打印的值是1，因为1025的二进制表示为00000000 00000000 00000100 00000001，解引用时只看一个字节即00000001，结果为1
	printf("Address = %p,value = %d\n", p0 + 1, *(p0 + 1));//地址p0大1，即一个字符型；00000100代表4，打印的值为4
}
    2.通用指针类型void
#include<stdio.h>
int main() {
	int a = 1025;
	int* p;
	p = &a;
	
	void* p0;
	p0 = p;
	printf("Address = %p", p0);
}
      不指向特定数据类型，导致不能直接解引用

五、指向指针的指针Pointer to pointer

示例
#include<stdio.h>
int main() {
	int a = 1025;
	int* p;
	p = &a;
	int** q;//指向指针的指针
	q = &p;
	int*** r;
	r = &q;//指向指针的指针的指针，*可以无限加
	
	printf("%d\n",*p);//1025
	printf("%p\n", *q);//0000004763CFFAC4，注意：这里用%d会有警告
	printf("%p\n", q);//0000004763CFFAE8
	printf("%d\n", *(*q));//1025，可以直接写**p，但是不建议
    printf("%d\n", *(*(*r)));//1025
    *(*(*r)) = 10;
    printf("%d\n", a);//10
	(*q)++;//写*q++会有一个“可能操作顺序不对”的警告
	printf("%p", p);//0000004763CFFAC8，比p加了一个整数型，即4个字节
}

六、函数传值和传引用

示例
#include<stdio.h>
void Increment(int a) {//这里的a是形参
	a = a + 1;
	printf("Address of a in Increment=%p\n", &a);//结果为Address of a in Increment=0000009814EFFB60
}
int main() {
	int a = 10;
	Increment(a);//这里的a是实参
	printf("Address of a in main = %p\n", &a);//结果为Address of a in main = 0000009814EFFB84
	printf("a = %d\n", a);//函数Increment中的a是局部变量，和主函数中的a不是一个a，结果为a = 10
}

1.应用程序的内存划分
  Code（text）储存指令，例如上述例子中的自增语句。
  Static/Global储存静态变量和全局变量（可以在任何函数中访问和修改）
  Stack（栈）存放局部变量
  Heap（堆）程序运行时在堆中为其分配更多内存
2.栈帧Stack frame
  （1）内存中会为了每个函数在栈上划分出来一个区域，即栈帧
       栈有大小，要防止溢出
  （2）在主调函数中调用被调函数时的参数称为实参
       实参会映射到形参
3.传值调用call by value
  一个函数中变量的值拷贝到另一个变量
4.传引用
示例
#include<stdio.h>
void Increment(int *p) {
	*p = (*p) + 1;
}
int main() {
	int a = 10;
	Increment(&a);//这里的实参不是a
	printf("a = %d\n", a);//结果为a= 11
}
传引用可以节省内存空间

七、指针和数组（array）
示例
#include<stdio.h>
int main() {
	int A[5] = { 2,4,6,8,10 };
	int* p;
	p = A;//可以写p++，不能写A++
	for (int i = 0; i < 5; i++) {
		printf("address of A[%d] is %p,and its value is %d\n", i, A + i,*(A+i));//此处A+i和P+i和&A[i]是一样的,*(A+i)和*（P+i）和A[i]是一样的
	}
}
//结果为address of A[0] is 0000007AE52FFCF8,and its value is 2
address of A[1] is 0000007AE52FFCFC,and its value is 4
address of A[2] is 0000007AE52FFD00,and its value is 6
address of A[3] is 0000007AE52FFD04,and its value is 8
address of A[4] is 0000007AE52FFD08,and its value is 10

   1.数组元素的首地址被称为数组的基地址（数组名称表示）

示例
#include<stdio.h>
int SumOfElements(int A[],int size) {
	int i, sum = 0;
	for (i = 0; i < size; i++) {
		sum += A[i];
	}
	return sum;
}
int main() {
	int A[] = { 1,2,3,4,5 };
	int size = sizeof(A) / sizeof(A[0]);
	int total = SumOfElements(A,size);
	printf("%d", total);//打印结果为15
}

#include<stdio.h>
int SumOfElements(int A[]) {//此处A[]是local variable
	int i, sum = 0;
	int size = sizeof(A) / sizeof(A[0]);
	printf("Size of A = %d\nsize of A[0] = %d\n", sizeof(A), sizeof(A[0]));
	for (i = 0; i < size; i++) {
		sum += A[i];
	}
	return sum;
}
int main() {
	int A[] = { 1,2,3,4,5 };
	int total = SumOfElements(A);
	printf("Sum of elements = %d", total);
}
//打印结果为Size of A = 8，但实际上字节应该为20
size of A[0] = 4
Sum of elements = 3

编译器仅仅创建实参中数组的首元素的地址，即仅创建一个同名指针，而不是拷贝整个A数组。在上述例子中，编译器隐式地把int A[]转换为int *A
数组总是传引用。
2.字符数组
如果储存一个字符串，需要比字符串大一个字节的数组，因为结尾有一个\0，即NUL字符
#include<stdio.h>
#include<string.h>
int main() {
	char C[20];
	C[0] = 'J';//单引号
	C[1] = 'h';
	C[2] = 'o';
	C[3] = 'n';
	C[4] = '\0';
	char s[] = "string";//\0是隐式的
	char m[5] = { 'm','a','t','h','\0' };//\0必须是显式的
	printf("%s\n", C);//双引号写char s[]; s="string";是不合法的，必须写在同一行
	printf("%s\n", s);
	printf("%s\n", m);
}

#include<stdio.h>
int main() {
	char c1[] = "hello";
	char* c2;
	c2 = c1;
	printf("%c", c2[0]);
	printf("%c", *(c2+1));
	printf("%c", c1[2]);
	printf("%c", *(c1 + 3));//数组总是传基地址
}

#include<stdio.h>
void print(char *C) {
	while (*C!= '\0') {
		printf("%c", *C);
		C++;
	}
	printf("\n");
}
int main() {
	char c[30] = "hello,batman!";
	print(c);
}

  3.指针和多维数组
   （1）多维数组
        int B[2][3]事实上是两个三元一维数组B[0]和B[1]
           B是数组名，会退化为指向B[0]（第一行数组）的指针，相当于&B[0]，类型是int (*)[3];
           *B相当于对于这个指向第一行的指针解引用，即B[0]，类型是int [3]，int*；
           B[0]退化为指向B[0][0]的指针，即&B[0][0]，类型是int*;
    (2)基地址B[0][0]
       B[i][j]=*(B[i]+j)
              =*(*(B+i)+j)
       B[i]指的是B[i]这个数组的基地址即B[i][0]
    (3)c[i][j][k]=*(c[i][j]+k)
                 =*(*(c[i]+j)+k)



    

